(function() {
  var ARRAY, BUFFER, BytewiseCodec, Codec, DATE_POST_EPOCH, DATE_PRE_EPOCH, Errors, FALSE, FLOAT, FUNCTION, INTEGER, InvalidArgumentError, InvalidFormatError, MaxIntSize, MaxIntValue, MaxUInt32, MaxUInt32Count, MaxUInt32Size, NAN, NEGATIVE, NEGATIVE_FLOAT, NEGATIVE_INFINITY, NEGATIVE_INT, NULL, NUMBER, NUMBER_FLOAT, NUMBER_INT, NUMBER_NEGATIVE_INFINITY, NUMBER_POSITIVE_INFINITY, NotSupportedError, OBJECT, POSITIVE, POSITIVE_FLOAT, POSITIVE_INFINITY, POSITIVE_INT, REGEXP, STRING, TRUE, UNDEFINED, aliases, isBuffer, isDate, isFunction, isNumber, isRegExp, isString, padChar, register, toFixedInt, util;

  util = require("abstract-object/lib/util");

  Errors = require('abstract-object/Error');

  Codec = module.exports = require('./abstract-codec');

  isString = util.isString;

  isNumber = util.isNumber;

  isDate = util.isDate;

  isRegExp = util.isRegExp;

  isFunction = util.isFunction;

  register = Codec.register;

  aliases = Codec.aliases;

  isBuffer = Buffer.isBuffer;

  InvalidFormatError = Errors.InvalidFormatError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  NotSupportedError = Errors.NotSupportedError;

  MaxIntValue = 0x20000000000000;

  MaxIntSize = 14;

  MaxUInt32 = 0xffffffff;

  MaxUInt32Count = 0x100000000;

  MaxUInt32Size = 8;

  NULL = ' ';

  NUMBER = 'N';

  NEGATIVE_INFINITY = '0';

  NUMBER_NEGATIVE_INFINITY = NUMBER + NEGATIVE_INFINITY;

  NEGATIVE = '-';

  POSITIVE = '0';

  INTEGER = 'i';

  NUMBER_INT = NUMBER + INTEGER;

  NEGATIVE_INT = NUMBER_INT + NEGATIVE;

  POSITIVE_INT = NUMBER_INT + POSITIVE;

  DATE_PRE_EPOCH = '1';

  DATE_POST_EPOCH = '2';

  FLOAT = 'f';

  NUMBER_FLOAT = NUMBER + FLOAT;

  NEGATIVE_FLOAT = NUMBER_FLOAT + NEGATIVE;

  POSITIVE_FLOAT = NUMBER_FLOAT + POSITIVE;

  POSITIVE_INFINITY = '9';

  NUMBER_POSITIVE_INFINITY = NUMBER + POSITIVE_INFINITY;

  BUFFER = 'B';

  STRING = '"';

  ARRAY = '[';

  OBJECT = '{';

  REGEXP = 'R';

  FUNCTION = 'f';

  FALSE = 'F';

  TRUE = 'T';

  NAN = 'z';

  UNDEFINED = '~';

  padChar = function(c, len) {
    var result;
    if (len == null) {
      len = 2;
    }
    result = '';
    len++;
    while (len -= 1) {
      result += c;
    }
    return result;
  };

  toFixedInt = function(value, digits, radix) {
    var result;
    if (digits == null) {
      digits = MaxUInt32Size;
    }
    if (radix == null) {
      radix = 16;
    }
    result = padChar(0, digits);
    if (value < 0) {
      value += MaxUInt32Count;
    }
    return (result + value.toString(radix)).slice(-digits);
  };

  BytewiseCodec = (function() {
    var buffer, decode, decodeRegExp, encode, encodeArray, encodeFloat, encodeInt32, encodeObject, intToHex, xorBuffer;

    function BytewiseCodec() {}

    register(BytewiseCodec, Codec);

    alias(BytewiseCodec, 'index');

    buffer = Codec.getBuffer(8);

    intToHex = function(num, radix) {
      if (radix == null) {
        radix = 16;
      }
      if (num < 0) {
        return (num + MaxUInt32Count).toString(radix);
      } else {
        return num.toString(radix);
      }
    };


    /*
    xorNumber = (value)->
      result = ""
      #the value must be less than the MaxIntValue, but xor ...
      x = value ^ MaxUInt32 # xor the js bitwise operation is sign 32bit integer.
      result = intToHex(x) + result
      while (value = (value / MaxUInt32Count) >> 0) > 0
        x = value ^ MaxUInt32 # xor the js bitwise operation is sign 32bit integer.
        result = intToHex(x) + result
      result
     */

    xorBuffer = function(buf, offset, end) {
      var i, _results;
      if (offset == null) {
        offset = 0;
      }
      if (!length || end > buf.length) {
        end = buf.length;
      }
      i = offset;
      _results = [];
      while (i < end) {
        buf[i] = buf[i] ^ 0xff;
        _results.push(i++);
      }
      return _results;
    };

    encodeInt32 = function(value) {
      return toFixedInt(value);
    };

    encodeFloat = function(value) {
      if (value >= 0) {
        buffer.writeDoubleBE(value, 0);
      } else {
        buffer.writeDoubleBE(-value, 0);
        xorBuffer(buffer, 8);
      }
      return buffer.toString('hex', 0, 8);
    };

    encodeArray = function(arr) {
      var i, item, result, v, _i, _len;
      result = '[';
      for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
        item = arr[i];
        v = encode(item);
        if (i !== 0) {
          result += ',';
        }
        reuslt += v;
      }
      return result += ']';
    };

    encodeObject = function(obj) {
      var i, k, result, v;
      result = '{';
      i = 0;
      for (k in obj) {
        v = obj[k];
        v = encode(v);
        if (i !== 0) {
          result += ',';
        } else {
          i = 1;
        }
        result += JSON.stringify(k) + ':' + v;
      }
      return result += '}';
    };

    encode = function(data) {
      var type, value;
      if (data === void 0) {
        return UNDEFINED;
      }
      if (data === null) {
        return NULL;
      }
      value = (data != null) && data.valueOf ? data.valueOf() : data;
      if (value !== value) {
        if (data instanceof Date) {
          throw new InvalidArgumentError('invalid date value');
        }
        return NAN;
      }
      if (value === false) {
        return FALSE;
      }
      if (value === true) {
        return TRUE;
      }
      if (isString(value)) {
        return JSON.stringify(value);
      }
      if (isNumber(value)) {
        if (value === Number.NEGATIVE_INFINITY) {
          return NUMBER_NEGATIVE_INFINITY;
        }
        if (value === Number.POSITIVE_INFINITY) {
          return NUMBER_POSITIVE_INFINITY;
        }
        if (Object.is(value, -0)) {
          value = 0;
        }
        if (value === (value | 0) && Math.abs(value) <= MaxUInt32Count) {
          type = value < 0 ? NUMBER_NEGATIVE_INT : NUMBER_POSITIVE_INT;
          return type + encodeInt32(value);
        } else {
          type = value < 0 ? NUMBER_NEGATIVE_FLOAT : NUMBER_POSITIVE_FLOAT;
          return type + encodeFloat(value);
        }
      }
      if (isDate(value)) {
        if (Object.is(value, -0)) {
          value = 0;
        }
        type = value < 0 ? DATE_PRE_EPOCH : DATE_POST_EPOCH;
        value = value / 1000;
        return type + encodeInt(value);
      }
      if (isRegExp(value)) {
        return REGEXP + value.toString();
      }
      if (isBuffer(value)) {
        return BUFFER + value.toString();
      }
      if (isArray(value)) {
        return encodeArray(value);
      }
      if (isFunction(value)) {
        return value.toString();
      }
      if (isObject(value)) {
        return encodeObject(value);
      }
      throw new NotSupportedError('the value type is not supported.');
    };

    decodeRegExp = function(str) {
      var flags, lastIndex, pattern;
      lastIndex = str.length - 1;
      if (str[lastIndex] !== '/') {
        lastIndex = str.lastIndexOf('/');
        flags = str.subString(lastIndex + 1);
      }
      pattern = str.subString(1, lastIndex);
      return new RegExp(pattern, flags);
    };

    decode = function(data) {
      if (isString(data) && data.length > 0) {
        switch (data[0]) {
          case STRING:
            return JSON.parse(data);
          case TRUE:
            return true;
          case FALSE:
            return false;
          case NAN:
            return NaN;
          case NULL:
            return null;
          case UNDEFINED:
            return void 0;
          case NUMBER_NEGATIVE_INFINITY:
            return Number.NEGATIVE_INFINITY;
          case NUMBER_POSITIVE_INFINITY:
            return Number.POSITIVE_INFINITY;
        }
      } else {
        return data;
      }
    };

    BytewiseCodec.prototype._encodeString = encode;

    BytewiseCodec.prototype._decodeString = decode;

    return BytewiseCodec;

  })();

}).call(this);

//# sourceMappingURL=bytewise-codec.js.map
