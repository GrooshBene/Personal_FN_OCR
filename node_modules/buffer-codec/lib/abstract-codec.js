(function() {
  var AbstractError, Codec, Errors, InvalidArgumentError, InvalidFormatError, InvalidUtf8Error, NotImplementedError, createError, factory, isBuffer, isString;

  factory = require("custom-factory");

  isString = require("util-ex/lib/is/type/string");

  Errors = require('abstract-error');

  createError = Errors.createError;

  AbstractError = Errors.AbstractError;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  InvalidFormatError = Errors.InvalidFormatError;

  InvalidUtf8Error = createError("InvalidUtf8", 0x81, InvalidFormatError);

  isBuffer = Buffer.isBuffer;

  Errors.InvalidUtf8Error = InvalidUtf8Error;

  module.exports = Codec = (function() {
    var UNSAFE_CHARS, escapeString, unescapeString;

    factory(Codec);

    UNSAFE_CHARS = '%';

    Codec.bufferSize = 1024;

    Codec.getBuffer = function(aBufferSize) {
      if (!Codec.buffer || Codec.buffer.length < aBufferSize) {
        aBufferSize || (aBufferSize = Codec.bufferSize);
        Codec.buffer = new Buffer(aBufferSize);
        Codec.bufferSize = aBufferSize;
      }
      return Codec.buffer;
    };

    Codec.formatName = function(aName) {
      return aName.toLowerCase();
    };

    function Codec(aCodecName, aBufferSize) {
      return Codec.__super__.constructor.apply(this, arguments);
    }

    Codec.prototype.initialize = function(aBufferSize) {
      if (this._encodeBuffer || aBufferSize > 0) {
        aBufferSize || (aBufferSize = Codec.bufferSize);
        if (!this.buffer || aBufferSize > this.buffer.length) {
          this.buffer = new Buffer(aBufferSize);
        }
        this.bufferSize = aBufferSize;
      }
      return this.buffer;
    };

    Codec.prototype.toString = function() {
      return this.name.toLowerCase();
    };

    Codec.prototype.isBuffer = function() {
      return this.buffer != null;
    };

    Codec.prototype.byteLength = function(value) {
      if (this._encodeBuffer) {
        return this.encodeBuffer(value);
      } else if (this._encodeString) {
        return this._encodeString(value).length;
      } else {
        throw new NotImplementedError();
      }
    };

    Codec.prototype.encodeString = function(value, bufferEncoding) {
      var len;
      if (bufferEncoding == null) {
        bufferEncoding = 'utf8';
      }
      if (this._encodeString) {
        return this._encodeString(value);
      } else if (this._encodeBuffer) {
        len = this._encodeBuffer(value, this.buffer, 0);
        return this.buffer.toString(bufferEncoding, 0, len);
      } else {
        throw new NotImplementedError();
      }
    };

    Codec.prototype.decodeString = function(str, bufferEncoding) {
      var len;
      if (bufferEncoding == null) {
        bufferEncoding = 'utf8';
      }
      if (this._decodeString) {
        return this._decodeString(str);
      } else if (this._decodeBuffer) {
        len = this.buffer.write(str);
        return this.decodeBuffer(this.buffer, 0, len, bufferEncoding);
      } else {
        throw new NotImplementedError();
      }
    };

    Codec.prototype.encodeBuffer = function(value, destBuffer, offset, encoding) {
      var len, result, resultIsBuffer;
      if (offset == null) {
        offset = 0;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (isString(offset)) {
        encoding = offset;
        offset = 0;
      }
      if (this._encodeBuffer) {
        return this._encodeBuffer(value, destBuffer, offset, encoding);
      } else if (this._encodeString) {
        result = this._encodeString(value);
        resultIsBuffer = isBuffer(result);
        if (isBuffer(destBuffer)) {
          if (resultIsBuffer) {
            len = Math.min(result.length, destBuffer.length - offset);
            result.copy(destBuffer, offset, 0, len);
            return len;
          } else {
            return destBuffer.write(result, offset, encoding);
          }
        } else if (resultIsBuffer) {
          return result.length;
        } else {
          return Codec.getByteLen(result);
        }
      } else {
        throw new NotImplementedError();
      }
    };

    Codec.prototype.decodeBuffer = function(buffer, start, end, encoding) {
      if (start == null) {
        start = 0;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (this._decodeBuffer) {
        return this._decodeBuffer(buffer, start, end, encoding);
      } else if (this._decodeString) {
        return this._decodeString(buffer.toString(encoding, start, end));
      } else {
        throw new NotImplementedError();
      }
    };

    Codec.prototype.ensureEncodeBuffer = function(buffer, encoding) {
      var destBuffer, len;
      if (encoding == null) {
        encoding = 'utf8';
      }
      len = this.encodeBuffer(buffer, null, 0, encoding);
      destBuffer = this.initialize(len);
      len = this.encodeBuffer(buffer, destBuffer, 0, encoding);
      return destBuffer.slice(0, len);
    };

    Codec.prototype.encode = function(value, options) {
      var result;
      options || (options = {});
      this.options = options;
      if (options.buffer) {
        if (options.buffer === true) {
          result = this.ensureEncodeBuffer(value, options.bufferEncoding);
        } else {
          result = this.encodeBuffer(value, options.buffer, options.bufferOffset, options.bufferEncoding);
        }
      } else {
        result = this.encodeString(value, options.bufferEncoding);
      }
      delete this.options;
      return result;
    };

    Codec.prototype.decode = function(value, options) {
      var result;
      options || (options = {});
      this.options = options;
      if (isBuffer(value)) {
        result = this.decodeBuffer(value, options.bufferStart, options.bufferEnd, options.bufferEncoding);
      } else {
        result = this.decodeString(value, options.bufferEncoding);
      }
      delete this.options;
      return result;
    };

    Codec.encode = function(value, options) {
      var encoding;
      if (!(options && options.encoding)) {
        return value;
      }
      encoding = options.encoding;
      if (!(encoding instanceof Codec)) {
        encoding = Codec(encoding);
        if (!encoding) {
          return value;
        }
      }
      return encoding.encode(value, options);
    };

    Codec.decode = function(value, options) {
      var encoding;
      if (!(options && options.encoding)) {
        return value;
      }
      encoding = options.encoding;
      if (!(encoding instanceof Codec)) {
        encoding = Codec(encoding);
        if (!encoding) {
          return value;
        }
      }
      return encoding.decode(value, options);
    };

    Codec.escapeString = escapeString = function(aString, aUnSafeChars) {
      var c, i, result, _i, _len;
      if (!isString(aString) || aString.length === 0) {
        return aString;
      }
      if (aUnSafeChars == null) {
        aUnSafeChars = UNSAFE_CHARS;
      }
      result = "";
      for (i = _i = 0, _len = aString.length; _i < _len; i = ++_i) {
        c = aString[i];
        result += aUnSafeChars.indexOf(c) >= 0 ? "%" + aString.charCodeAt(i).toString(16) : c;
      }
      return result;
    };

    Codec.unescapeString = unescapeString = decodeURIComponent;


    /*
     * Count bytes in a string's UTF-8 representation.
     *
     * @param   string
     * @return  int
     *
     */

    Codec.getByteLen = function(str) {
      var c, i, result, _, _i, _len;
      str = String(str);
      result = 0;
      for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
        _ = str[i];
        c = str.charCodeAt(i);
        result += c < (1 << 7) ? 1 : c < (1 << 11) ? 2 : c < (1 << 16) ? 3 : c < (1 << 21) ? 4 : c < (1 << 26) ? 5 : c < (1 << 31) ? 6 : Number.NaN;
      }
      return result;
    };

    Codec.utf8Slice = function(buf, start, end) {
      var i, result, tmp, _i;
      result = '';
      tmp = '';
      end = Math.min(buf.length, end);
      for (i = _i = start; start <= end ? _i < end : _i > end; i = start <= end ? ++_i : --_i) {
        if (buf[i] <= 0x7F) {
          result += decodeURIComponent(tmp) + String.fromCharCode(buf[i]);
          tmp = '';
        } else {
          tmp += '%' + buf[i].toString(16);
        }
      }
      return result + decodeURIComponent(tmp);
    };

    Codec.utf8ToBytes = function(string, units) {
      var bytes, codePoint, i, leadSurrogate, length, _, _i, _len;
      length = string.length;
      leadSurrogate = null;
      units = units || Infinity;
      bytes = [];
      for (i = _i = 0, _len = string.length; _i < _len; i = ++_i) {
        _ = string[i];
        codePoint = string.charCodeAt(i);
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          if (leadSurrogate) {
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) {
                bytes.push(0xEF, 0xBF, 0xBD);
              }
              leadSurrogate = codePoint;
              continue;
            } else {
              codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
              leadSurrogate = null;
            }
          } else {
            if (codePoint > 0xDBFF) {
              if ((units -= 3) > -1) {
                bytes.push(0xEF, 0xBF, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) {
                bytes.push(0xEF, 0xBF, 0xBD);
              }
              continue;
            } else {
              leadSurrogate = codePoint;
              continue;
            }
          }
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) {
            bytes.push(0xEF, 0xBF, 0xBD);
          }
          leadSurrogate = null;
        }
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) {
            break;
          }
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) {
            break;
          }
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) {
            break;
          }
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x200000) {
          if ((units -= 4) < 0) {
            break;
          }
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new InvalidUtf8Error('utf8:Invalid code point');
        }
      }
      return bytes;
    };

    return Codec;

  })();

}).call(this);

//# sourceMappingURL=abstract-codec.js.map
