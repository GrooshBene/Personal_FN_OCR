(function() {
  var BinaryCodec, Codec, Errors, HexCodec, InvalidFormatError, JsonCodec, TextCodec, aliases, isBuffer, isString, register;

  Errors = require('abstract-error');

  Codec = module.exports = require('./abstract-codec');

  isString = require("util-ex/lib/is/type/string");

  register = Codec.register;

  aliases = Codec.aliases;

  isBuffer = Buffer.isBuffer;

  InvalidFormatError = Errors.InvalidFormatError;

  TextCodec = (function() {
    function TextCodec() {}

    register(TextCodec, Codec);

    aliases(TextCodec, 'utf8', 'utf-8');

    TextCodec.prototype._encodeString = function(data) {
      if ((data == null) || isBuffer(data)) {
        return data;
      } else {
        return String(data);
      }
    };

    TextCodec.prototype._decodeString = function(data) {
      return data;
    };

    TextCodec.prototype.byteLength = function(data) {
      if (data != null) {
        return data.length || String(data).length;
      } else {
        return 0;
      }
    };

    return TextCodec;

  })();

  JsonCodec = (function() {
    function JsonCodec() {}

    register(JsonCodec, TextCodec);

    JsonCodec.prototype._encodeString = JSON.stringify;

    JsonCodec.prototype._decodeString = JSON.parse;

    JsonCodec.prototype.byteLength = function(data) {
      return this._encodeString(data).length;
    };

    return JsonCodec;

  })();

  HexCodec = (function() {
    function HexCodec() {}

    register(HexCodec, TextCodec);

    HexCodec.prototype.bufferEncoding = 'hex';

    HexCodec.prototype.byteToHex = function(byte) {
      if (byte < 16) {
        return '0' + byte.toString(16);
      } else {
        return byte.toString(16);
      }
    };

    HexCodec.prototype._encodeString = function(data) {
      var byte, i, length, result;
      length = data.length;
      if (length % 2 !== 0) {
        throw new InvalidFormatError('invalid hex string.');
      }
      length = length >> 1;
      result = "";
      i = 0;
      while (i < length) {
        byte = parseInt(data.substr(i * 2, 2), 16);
        result += String.fromCharCode(byte);
        i++;
      }
      return result;
    };

    HexCodec.prototype._decodeString = function(data) {
      var i, result;
      result = "";
      i = 0;
      while (i < data.length) {
        result += this.byteToHex(data.charCodeAt(i));
        i++;
      }
      return result;
    };

    HexCodec.prototype._encodeBuffer = function(data, destBuffer, offset, encoding) {
      var length;
      offset = Number(offset) || 0;
      length = data.length;
      if (length % 2 !== 0) {
        throw new InvalidFormatError('invalid hex string.');
      }
      length = length >> 1;
      if (isBuffer(destBuffer)) {
        length = destBuffer.write(data, offset, length, 'hex');
      }
      return length;
    };

    HexCodec.prototype._encodeBuffer2 = function(data, destBuffer, offset, encoding) {
      var byte, i, length;
      offset = Number(offset) || 0;
      length = data.length;
      if (length % 2 !== 0) {
        throw new InvalidFormatError('invalid hex string.');
      }
      length = length >> 1;
      if (isBuffer(destBuffer)) {
        i = destBuffer.length - offset;
        if (length > i) {
          length = i;
        }
        i = 0;
        while (i < length) {
          byte = parseInt(data.substr(i * 2, 2), 16);
          if (isNaN(byte)) {
            throw new InvalidFormatError('invalid hex string.');
          }
          destBuffer[offset + i] = byte;
          i++;
        }
      }
      return length;
    };

    HexCodec.prototype._decodeBuffer = function(buf, start, end) {
      return buf.toString('hex', start, end);
    };

    HexCodec.prototype._decodeBuffer2 = function(buf, start, end) {
      var len, result;
      len = buf.length;
      if (!start || start < 0) {
        start = 0;
      }
      if (!end || end < 0 || end > len) {
        end = len;
      }
      result = "";
      while (start < end) {
        result += this.byteToHex(buf[start]);
        start++;
      }
      return result;
    };

    HexCodec.prototype.byteLength = function(data) {
      return data.length >> 1;
    };

    return HexCodec;

  })();

  BinaryCodec = (function() {
    var arraySlice;

    function BinaryCodec() {}

    register(BinaryCodec, Codec);

    arraySlice = Array.prototype.slice;

    BinaryCodec.prototype.toArray = function(data) {
      return arraySlice.call(data);
    };

    BinaryCodec.prototype.byteLength = function(data) {
      var arr;
      if (isBuffer(data)) {
        return data.length;
      } else if (isString(data)) {
        return Codec.getByteLen(data);
      } else {
        arr = arraySlice.call(data);
        return arr.length;
      }
    };

    BinaryCodec.prototype._encodeBuffer = function(data, destBuffer, offset, encoding) {
      var arr, dataIsBuffer, i, len, v, _i, _len;
      if (data == null) {
        return 0;
      } else {
        dataIsBuffer = isBuffer(data);
        if (isBuffer(destBuffer)) {
          if (dataIsBuffer) {
            len = Math.min(data.length, destBuffer.length - offset);
            data.copy(destBuffer, offset, 0, len);
            return len;
          } else if (isString(data)) {
            return destBuffer.write(data, offset, encoding);
          } else {
            if (!(offset > 0)) {
              offset = 0;
            }
            arr = arraySlice.call(data);
            if (arr.length > 0) {
              for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
                v = arr[i];
                destBuffer.writeUInt8(v, i + offset, true);
              }
            }
            return arr.length;
          }
        } else {
          if (dataIsBuffer) {
            return data.length;
          } else if (isString(data)) {
            return Codec.getByteLen(data);
          } else {
            arr = arraySlice.call(data);
            return arr.length;
          }
        }
      }
    };

    BinaryCodec.prototype._decodeBuffer = function(data, start, end) {
      if ((data != null) && (start != null) && end && data.slice) {
        return data.slice(start, end);
      } else {
        return data;
      }
    };

    return BinaryCodec;

  })();

}).call(this);

//# sourceMappingURL=codec.js.map
