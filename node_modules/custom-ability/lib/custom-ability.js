(function() {
  'use strict';
  var defineProperty, extend, extendFilter, getNonEnumNames, injectMethod, injectMethods, injectMethodsFromNonEnum, isArray, isBoolean, isFunction, isInjectedOnParent,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  isArray = require('util-ex/lib/is/type/array');

  isFunction = require('util-ex/lib/is/type/function');

  isBoolean = require('util-ex/lib/is/type/boolean');

  extend = require('util-ex/lib/_extend');

  extendFilter = require('util-ex/lib/extend');

  injectMethods = require('util-ex/lib/injectMethods');

  injectMethod = require('util-ex/lib/injectMethod');

  defineProperty = require('util-ex/lib/defineProperty');

  getNonEnumNames = require('util-ex/lib/get-non-enumerable-names');

  isInjectedOnParent = require('./injected-on-parent');

  injectMethodsFromNonEnum = function(aTargetClass, aObject, filter, isStatic) {
    var nonEnumNames, result;
    nonEnumNames = getNonEnumNames(aObject);
    result = [];
    nonEnumNames.forEach(function(k) {
      var v, vK;
      if (k[0] === '$' && isFunction(v = aObject[k])) {
        k = k.substr(1);
        vK = isStatic ? '@' + k : k;
        if (!filter || filter(vK)) {
          if (isFunction(aTargetClass[k])) {
            injectMethod(aTargetClass, k, v);
          } else if (aTargetClass[k] != null) {
            throw new TypeError('the same non-null name is not function:' + k);
          } else {
            aTargetClass[k] = v;
          }
          delete aObject[k];
          result.push(vK);
        }
      }
    });
    return result;
  };

  module.exports = function(abilityClass, aCoreMethod, isGetClassFunc) {
    var abilityFn, filter, getAdditionalAbility, injectAdditionalAbility;
    if (isBoolean(aCoreMethod)) {
      isGetClassFunc = aCoreMethod;
      aCoreMethod = void 0;
    }
    abilityFn = function(aClass, aOptions) {
      var $abilities, AbilityClass, aClassPrototype, filterMethods, vAbilities, vAddtionalAbilityInjected, vExcludes, vFilter, vIncludes, vInjectedOnParent, vName, vhasCoreMethod;
      AbilityClass = abilityClass;
      if (isGetClassFunc === true) {
        AbilityClass = abilityClass(aClass, aOptions);
      }
      if (!AbilityClass) {
        throw new TypeError('no abilityClass');
      }
      vName = AbilityClass.name;
      if (aClass != null) {
        aClassPrototype = aClass.prototype;
        vhasCoreMethod = isArray(aCoreMethod) ? aCoreMethod[0] : aCoreMethod;
        if (vhasCoreMethod) {
          if (vhasCoreMethod[0] !== '@') {
            vhasCoreMethod = aClass.prototype.hasOwnProperty(vhasCoreMethod);
          } else {
            vhasCoreMethod = vhasCoreMethod.substr(1);
            vhasCoreMethod = aClass.hasOwnProperty(vhasCoreMethod);
          }
        }
        if (vName) {
          $abilities = aClass.prototype.$abilities;
          vInjectedOnParent = isInjectedOnParent(aClass, vName);
          if (!aClass.prototype.hasOwnProperty('$abilities')) {
            $abilities = null;
          }
        }
        if (!(vhasCoreMethod || ($abilities && $abilities['$' + vName]))) {
          if ((aOptions == null) || !(aOptions.include || aOptions.exclude)) {
            if (vName) {
              vAddtionalAbilityInjected = injectAdditionalAbility(aClass, vName, filterMethods);
            }
            vExcludes = injectMethodsFromNonEnum(aClass, AbilityClass, null, true);
            extendFilter(aClass, AbilityClass, function(k) {
              return !(indexOf.call(vExcludes, k) >= 0);
            });
            if (vAddtionalAbilityInjected) {
              aClassPrototype = vAddtionalAbilityInjected.prototype;
            }
            if (!vInjectedOnParent) {
              vExcludes = injectMethodsFromNonEnum(aClassPrototype, AbilityClass.prototype);
              extend(aClassPrototype, AbilityClass.prototype, function(k) {
                return !(indexOf.call(vExcludes, k) >= 0);
              });
            }
          } else {
            vIncludes = aOptions.include;
            if (vIncludes) {
              if (!isArray(vIncludes)) {
                vIncludes = [vIncludes];
              }
            } else {
              vIncludes = [];
            }
            if (aCoreMethod) {
              if (isArray(aCoreMethod)) {
                vIncludes = vIncludes.concat(aCoreMethod);
              } else {
                vIncludes.push(aCoreMethod);
              }
            }
            vExcludes = aOptions.exclude;
            if (vExcludes) {
              if (!isArray(vExcludes)) {
                vExcludes = [vExcludes];
              }
            } else {
              vExcludes = [];
            }
            vFilter = function(isStatic) {
              return function(k) {
                return filter(k, vIncludes, vExcludes, isStatic);
              };
            };
            vAbilities = injectMethodsFromNonEnum(aClass, AbilityClass, vFilter(true), true);
            vAbilities = vAbilities.concat(injectMethodsFromNonEnum(aClass.prototype, AbilityClass.prototype, vFilter()));
            vExcludes = vExcludes.concat(vAbilities);
            vAbilities = void 0;
            filterMethods = function(methods) {
              var k;
              if (methods instanceof Object) {
                for (k in methods) {
                  if (!vFilter(k)) {
                    delete methods[k];
                  }
                }
              }
            };
            if (vName) {
              vAddtionalAbilityInjected = injectAdditionalAbility(aClass, vName, filterMethods);
            }
            extendFilter(aClass, AbilityClass, vFilter(true));
            if (vAddtionalAbilityInjected) {
              aClassPrototype = vAddtionalAbilityInjected.prototype;
            }
            if (!vInjectedOnParent) {
              extendFilter(aClassPrototype, AbilityClass.prototype, vFilter());
            }
            filterMethods(aOptions.methods);
            filterMethods(aOptions.classMethods);
          }
          if (aOptions != null) {
            if (!vInjectedOnParent && aOptions.methods instanceof Object) {
              injectMethods(aClassPrototype, aOptions.methods, aOptions);
            }
            if (aOptions.classMethods instanceof Object) {
              injectMethods(aClass, aOptions.classMethods, aOptions);
            }
          }
          if (vName) {
            if (aClassPrototype !== aClass.prototype) {
              aClassPrototype = aClass.prototype;
            }
            if (!aClassPrototype.hasOwnProperty('$abilities')) {
              $abilities = {};
              defineProperty(aClassPrototype, '$abilities', $abilities);
            }
            $abilities['$' + vName] = abilityFn;
          }
        }
      } else {
        aClass = AbilityClass;
      }
      return aClass;
    };
    abilityFn.filter = filter = function(k, aIncludes, aExcludes, aIsStatic) {
      var result;
      if (aIsStatic) {
        k = '@' + k;
      }
      result = aIncludes.length;
      if (result) {
        result = indexOf.call(aIncludes, k) >= 0;
        if (!result && aExcludes.length) {
          result = !(indexOf.call(aExcludes, k) >= 0);
        }
      } else if (aExcludes.length) {
        result = !(indexOf.call(aExcludes, k) >= 0);
      } else {
        result = true;
      }
      return result;
    };
    getAdditionalAbility = function(aClass, aName) {
      var result;
      result = [];
      while (aClass && aClass.prototype) {
        if (aClass.prototype.hasOwnProperty('$abilities') && !aClass.prototype.$abilities['$' + aName] && aClass.prototype.$abilities[aName]) {
          result.push(aClass);
        }
        aClass = aClass.super_;
      }
      return result;
    };
    injectAdditionalAbility = function(aClass, aName, filterMethods) {
      var $abilities, result, vAbility, vOptions;
      while (aClass && aClass.prototype) {
        if (aClass.prototype.hasOwnProperty('$abilities')) {
          $abilities = aClass.prototype.$abilities;
          if (!$abilities['$' + aName] && (vAbility = $abilities[aName])) {
            vOptions = vAbility();
            $abilities['$' + aName] = abilityFn;
            result = aClass;
            if (vOptions != null) {
              if (filterMethods) {
                filterMethods(vOptions.methods);
                filterMethods(vOptions.classMethods);
              }
              if (vOptions.methods instanceof Object) {
                injectMethods(aClass.prototype, vOptions.methods, vOptions);
              }
              if (vOptions.classMethods instanceof Object) {
                injectMethods(aClass, vOptions.classMethods, vOptions);
              }
            }
          }
        }
        aClass = aClass.super_;
      }
      return result;
    };
    return abilityFn;
  };

}).call(this);

//# sourceMappingURL=custom-ability.js.map
